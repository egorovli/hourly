import type { AuditRequestContext } from './request-context.ts'

import type { AuditLogActionType } from '~/domain/audit-log-action-type.enum.ts'
import type { AuditLogOutcome } from '~/domain/audit-log-outcome.enum.ts'
import { AuditLogSeverity } from '~/domain/audit-log-severity.enum.ts'
import type { AuditLogTargetResourceType } from '~/domain/audit-log-target-resource-type.enum.ts'
import { AuditLog, orm } from '~/lib/mikro-orm/index.ts'

import { sanitizeActionDescription, sanitizeMetadata, sanitizeUserAgent } from './sanitize.ts'

/**
 * Input for creating an audit log entry.
 */
export interface CreateAuditLogInput {
	actionType: AuditLogActionType
	actionDescription: string
	targetResourceType: AuditLogTargetResourceType
	outcome: AuditLogOutcome
	severity?: AuditLogSeverity
	targetResourceId?: string
	metadata?: Record<string, unknown>
	parentEventId?: string
}

/**
 * AuditLogger service for logging audit events within a request context.
 * Batches events and flushes them at the end of the request.
 */
export class AuditLogger {
	private events: AuditLog[] = []
	private sequenceCounter = 0
	private flushed = false
	private actorProfileId?: string
	private actorProvider?: string

	constructor(private context: AuditRequestContext) {}

	/**
	 * Set the actor for subsequent log entries.
	 * Call this after authentication succeeds.
	 */
	setActor(profileId: string, provider: string): void {
		this.actorProfileId = profileId
		this.actorProvider = provider
	}

	/**
	 * Log an audit event.
	 * Events are batched and flushed at the end of the request.
	 */
	log(input: CreateAuditLogInput): AuditLog {
		const event = new AuditLog()

		// IDs and timestamps are auto-generated by the entity
		event.occurredAt = new Date()

		// Actor (set after authentication)
		event.actorProfileId = this.actorProfileId
		event.actorProvider = this.actorProvider

		// Action
		event.actionType = input.actionType
		event.actionDescription = sanitizeActionDescription(input.actionDescription)
		event.severity = input.severity ?? AuditLogSeverity.Info

		// Target
		event.targetResourceType = input.targetResourceType
		event.targetResourceId = input.targetResourceId

		// Result
		event.outcome = input.outcome

		// Correlation
		event.correlationId = this.context.correlationId
		event.sessionId = this.context.sessionId
		event.requestId = this.context.requestId

		// Request context
		event.requestPath = this.context.requestPath
		event.requestMethod = this.context.requestMethod
		event.ipAddress = this.context.ipAddress
		event.userAgent = sanitizeUserAgent(this.context.userAgent)

		// Performance & hierarchy
		event.durationMs = Date.now() - this.context.startTime
		event.parentEventId = input.parentEventId
		event.sequenceNumber = this.sequenceCounter++

		// Metadata
		if (input.metadata) {
			event.metadata = sanitizeMetadata(input.metadata)
		}

		this.events.push(event)
		return event
	}

	/**
	 * Flush all batched events to the database.
	 * Uses best-effort strategy: logs to console on DB failure.
	 * Safe to call multiple times (idempotent after first flush).
	 */
	async flush(): Promise<void> {
		if (this.flushed || this.events.length === 0) {
			return
		}

		this.flushed = true

		try {
			const em = orm.em.fork()
			for (const event of this.events) {
				em.persist(event)
			}
			await em.flush()
		} catch (error) {
			// Best-effort: log to console on DB failure, don't fail the request
			// biome-ignore lint/suspicious/noConsole: Required for audit log fallback
			console.error('[AuditLog] Failed to persist events:', error)
			// biome-ignore lint/suspicious/noConsole: Required for audit log fallback
			console.error(
				'[AuditLog] Lost events:',
				JSON.stringify(
					this.events.map(e => ({
						id: e.id,
						actionType: e.actionType,
						actionDescription: e.actionDescription,
						outcome: e.outcome
					}))
				)
			)
		}
	}

	/**
	 * Clear the event buffer.
	 * Call this in finally blocks to prevent memory leaks.
	 */
	clear(): void {
		this.events = []
	}

	/**
	 * Get the correlation ID for this request.
	 */
	getCorrelationId(): string {
		return this.context.correlationId
	}

	/**
	 * Get the request ID for this request.
	 */
	getRequestId(): string {
		return this.context.requestId
	}
}

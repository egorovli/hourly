name: Deploy

# Security: Explicit permissions for GITHUB_TOKEN
permissions:
  contents: read
  packages: read
  id-token: write
  actions: read

# Concurrency: Prevent multiple deployments for the same target
concurrency:
  group: deploy-${{ inputs.environment }}-${{ github.ref_name }}
  cancel-in-progress: false

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Docker image tag to deploy (e.g., latest, main, sha-abc1234, v1.0.0). Defaults to "latest"'
        required: false
        type: string
        default: 'latest'
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - staging
          - production
      workflow_run_id:
        description: 'Optional: Build workflow run ID to verify (leave empty to use latest successful build)'
        required: false
        type: string
      dry_run:
        description: 'Dry run mode (echo only, no actual deployment)'
        required: false
        type: boolean
        default: true

run-name: "Deployment to ${{ github.event.inputs.environment }} (${{ github.event.inputs.image_tag || 'latest' }}) by @${{ github.actor }}"

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/web

defaults:
  run:
    shell: bash

jobs:
  verify-build:
    name: Verify Build Workflow
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: contains('egorovli', github.actor)
    outputs:
      build_workflow_run_id: ${{ steps.verify.outputs.workflow_run_id }}
      build_sha: ${{ steps.verify.outputs.build_sha }}
      image_exists: ${{ steps.image-check.outputs.image_exists }}
      image_digest: ${{ steps.image-check.outputs.image_digest }}
      resolved_tag: ${{ steps.resolve-final.outputs.resolved_tag }}
      resolved_sha: ${{ steps.resolve-final.outputs.resolved_sha }}
      resolved_sha_short: ${{ steps.resolve-final.outputs.resolved_sha_short }}
      full_image: ghcr.io/${{ github.repository }}/web:${{ inputs.image_tag || 'latest' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Verify GitHub CLI
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          
          # GitHub CLI is pre-installed and authenticates automatically with GITHUB_TOKEN
          echo "Verifying GitHub CLI availability..."
          gh --version
          
          # Verify authentication
          CURRENT_USER=$(gh api user --jq '.login' 2>/dev/null || echo "")
          if [[ -z "${CURRENT_USER}" ]]; then
            echo "❌ GitHub CLI authentication failed"
            exit 1
          fi
          echo "✅ Authenticated as: ${CURRENT_USER}"

      - name: Verify build workflow completion
        id: verify
        env:
          BUILD_WORKFLOW_ID: ${{ inputs.workflow_run_id }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          
          echo "🔍 Verifying build workflow completion..."
          
          # Determine which workflow run to check
          if [[ -n "${BUILD_WORKFLOW_ID:-}" ]]; then
            echo "Using specified workflow run ID: ${BUILD_WORKFLOW_ID}"
            WORKFLOW_RUN_ID="${BUILD_WORKFLOW_ID}"
          else
            echo "Finding latest successful build workflow run..."
            WORKFLOW_RUN_ID=$(gh run list \
              --workflow="build.yml" \
              --branch="${{ github.ref_name }}" \
              --status=success \
              --limit=1 \
              --json databaseId \
              --jq '.[0].databaseId' \
              || echo "")
            
            if [[ -z "${WORKFLOW_RUN_ID}" ]]; then
              echo "❌ No successful build workflow found for branch: ${{ github.ref_name }}"
              exit 1
            fi
            
            echo "Found latest successful build: ${WORKFLOW_RUN_ID}"
          fi
          
          # Verify workflow run exists and succeeded
          WORKFLOW_STATUS=$(gh run view "${WORKFLOW_RUN_ID}" \
            --json conclusion \
            --jq '.conclusion' \
            || echo "null")
          
          if [[ "${WORKFLOW_STATUS}" != "success" ]]; then
            echo "❌ Build workflow ${WORKFLOW_RUN_ID} did not succeed (status: ${WORKFLOW_STATUS})"
            exit 1
          fi
          
          # Get commit SHA from workflow run
          BUILD_SHA=$(gh run view "${WORKFLOW_RUN_ID}" \
            --json headSha \
            --jq '.headSha' \
            || echo "")
          
          if [[ -z "${BUILD_SHA}" ]]; then
            echo "❌ Could not determine build SHA"
            exit 1
          fi
          
          echo "✅ Build workflow verified: ${WORKFLOW_RUN_ID}"
          echo "Build SHA: ${BUILD_SHA}"
          echo "workflow_run_id=${WORKFLOW_RUN_ID}" >> $GITHUB_OUTPUT
          echo "build_sha=${BUILD_SHA}" >> $GITHUB_OUTPUT

      - name: Setup Docker
        uses: docker/setup-buildx-action@v3.11.1

      - name: Verify image exists in registry
        id: image-check
        env:
          REGISTRY: ghcr.io
          IMAGE_NAME: ${{ github.repository }}/web
          IMAGE_TAG: ${{ inputs.image_tag || 'latest' }}
        run: |
          set -euo pipefail
          
          echo "🔍 Verifying image exists in registry..."
          
          FULL_IMAGE="${REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}"
          echo "Checking image: ${FULL_IMAGE}"
          
          # Login to registry
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login "${REGISTRY}" \
            --username "${{ github.actor }}" \
            --password-stdin
          
          # Check if image exists using docker manifest inspect
          if docker manifest inspect "${FULL_IMAGE}" > /dev/null 2>&1; then
            echo "✅ Image found: ${FULL_IMAGE}"
            echo "image_exists=true" >> $GITHUB_OUTPUT
            
            # Get image digest for verification (jq is pre-installed on GitHub runners)
            MANIFEST_JSON=$(docker manifest inspect "${FULL_IMAGE}" 2>/dev/null || echo "")
            if [[ -n "${MANIFEST_JSON}" ]]; then
              # Try to extract digest using jq if available
              if command -v jq >/dev/null 2>&1; then
                IMAGE_DIGEST=$(echo "${MANIFEST_JSON}" | jq -r '.config.digest // empty' 2>/dev/null || echo "")
                if [[ -n "${IMAGE_DIGEST}" && "${IMAGE_DIGEST}" != "null" ]]; then
                  echo "Image digest: ${IMAGE_DIGEST}"
                  echo "image_digest=${IMAGE_DIGEST}" >> $GITHUB_OUTPUT
                fi
              fi
              
              # Extract short SHA from manifest for reference
              echo "Full image reference: ${FULL_IMAGE}"
            fi
          else
            echo "❌ Image not found: ${FULL_IMAGE}"
            echo "image_exists=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Resolve tag to commit SHA (finalize)
        id: resolve-final
        env:
          IMAGE_TAG: ${{ inputs.image_tag || 'latest' }}
          BUILD_SHA: ${{ steps.verify.outputs.build_sha }}
        run: |
          set -euo pipefail
          
          # If tag is already a SHA, use it
          if [[ "${IMAGE_TAG}" =~ ^[0-9a-f]{7,}$ ]]; then
            RESOLVED_SHA="${IMAGE_TAG}"
            echo "✅ Tag is commit SHA: ${RESOLVED_SHA}"
          else
            # Otherwise, use the build SHA from the verified workflow
            RESOLVED_SHA="${BUILD_SHA}"
            echo "✅ Resolved tag '${IMAGE_TAG}' to commit SHA: ${RESOLVED_SHA}"
          fi
          
          echo "resolved_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "resolved_sha=${RESOLVED_SHA}" >> $GITHUB_OUTPUT
          
          # Output short SHA for display
          SHORT_SHA="${RESOLVED_SHA:0:7}"
          echo "resolved_sha_short=${SHORT_SHA}" >> $GITHUB_OUTPUT

  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs:
      - verify-build
    if: needs.verify-build.outputs.image_exists == 'true'
    env:
      REGISTRY: ghcr.io
      IMAGE_NAME: ${{ github.repository }}/web
      FULL_IMAGE: ${{ needs.verify-build.outputs.full_image }}
      IMAGE_TAG: ${{ inputs.image_tag || 'latest' }}
      RESOLVED_TAG: ${{ needs.verify-build.outputs.resolved_tag }}
      RESOLVED_SHA: ${{ needs.verify-build.outputs.resolved_sha }}
      RESOLVED_SHA_SHORT: ${{ needs.verify-build.outputs.resolved_sha_short }}
      ENVIRONMENT: ${{ inputs.environment }}
      BUILD_SHA: ${{ needs.verify-build.outputs.build_sha }}
      BUILD_RUN_ID: ${{ needs.verify-build.outputs.build_workflow_run_id }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Validate deployment parameters
        run: |
          set -euo pipefail
          
          echo "🔍 Validating deployment parameters..."
          
          # Validate image tag format
          IMAGE_TAG="${IMAGE_TAG}"
          if [[ ! "${IMAGE_TAG}" =~ ^[a-zA-Z0-9._-]+$ ]]; then
            echo "❌ Invalid image tag format: ${IMAGE_TAG}"
            echo "Tag must contain only alphanumeric characters, dots, underscores, and hyphens"
            exit 1
          fi
          
          # Validate environment
          ENVIRONMENT="${ENVIRONMENT}"
          if [[ "${ENVIRONMENT}" != "staging" && "${ENVIRONMENT}" != "production" ]]; then
            echo "❌ Invalid environment: ${ENVIRONMENT}"
            echo "Environment must be 'staging' or 'production'"
            exit 1
          fi
          
          echo "✅ All parameters validated"

      - name: Display deployment parameters
        run: |
          set -euo pipefail
          
          echo "## Deployment Parameters" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Image Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Registry:** \`${REGISTRY}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Name:** \`${IMAGE_NAME}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag:** \`${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY
          if [[ -n "${RESOLVED_SHA}" ]]; then
            echo "- **Resolved SHA:** \`${RESOLVED_SHA_SHORT}\` (${RESOLVED_SHA})" >> $GITHUB_STEP_SUMMARY
          fi
          echo "- **Full Image:** \`${FULL_IMAGE}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** \`${{ inputs.environment }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Dry Run:** \`${{ inputs.dry_run }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered By:** \`${{ github.actor }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit SHA:** \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Build Verification" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Workflow Run ID:** \`${{ needs.verify-build.outputs.build_workflow_run_id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Commit SHA:** \`${{ needs.verify-build.outputs.build_sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Verified:** ✅" >> $GITHUB_STEP_SUMMARY
          IMAGE_DIGEST="${{ needs.verify-build.outputs.image_digest }}"
          if [[ -n "${IMAGE_DIGEST}" ]]; then
            echo "- **Image Digest:** \`${IMAGE_DIGEST}\`" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "🚀 DEPLOYMENT PARAMETERS"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""
          echo "Image Information:"
          echo "  Registry:        ${REGISTRY}"
          echo "  Image Name:      ${IMAGE_NAME}"
          echo "  Image Tag:       ${IMAGE_TAG}"
          if [[ -n "${RESOLVED_SHA}" ]]; then
            echo "  Resolved SHA:    ${RESOLVED_SHA_SHORT} (${RESOLVED_SHA})"
          fi
          echo "  Full Image:      ${FULL_IMAGE}"
          echo ""
          echo "Deployment Configuration:"
          echo "  Environment:     ${ENVIRONMENT}"
          echo "  Dry Run:         ${{ inputs.dry_run }}"
          echo "  Triggered By:    ${{ github.actor }}"
          echo "  Branch:          ${{ github.ref_name }}"
          echo "  Commit SHA:      ${{ github.sha }}"
          echo ""
          echo "Build Verification:"
          echo "  Build Run ID:    ${{ needs.verify-build.outputs.build_workflow_run_id }}"
          echo "  Build SHA:       ${{ needs.verify-build.outputs.build_sha }}"
          IMAGE_DIGEST="${{ needs.verify-build.outputs.image_digest }}"
          if [[ -n "${IMAGE_DIGEST}" ]]; then
            echo "  Image Digest:   ${IMAGE_DIGEST}"
          fi
          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

      - name: Execute deployment stub
        if: inputs.dry_run == true
        run: |
          set -euo pipefail
          
          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "🔍 DRY RUN MODE - No actual deployment"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""
          echo "In production mode, this step would:"
          echo "  1. Connect to deployment target (SSH/Kubernetes/Helm)"
          echo "  2. Pull image: ${REGISTRY}/${IMAGE_NAME}:${{ inputs.image_tag }}"
          echo "  3. Update deployment configuration"
          echo "  4. Perform health checks"
          echo "  5. Rollback on failure"
          echo ""
          echo "Deployment command would be:"
          echo "  docker pull ${FULL_IMAGE}"
          echo "  # OR"
          echo "  kubectl set image deployment/app app=${FULL_IMAGE} -n ${ENVIRONMENT}"
          echo "  # OR"
          echo "  helm upgrade app ./chart --set image.tag=${IMAGE_TAG} -n ${ENVIRONMENT}"
          echo ""
          echo "Available environment variables:"
          echo "  FULL_IMAGE=${FULL_IMAGE}"
          echo "  IMAGE_TAG=${IMAGE_TAG}"
          echo "  ENVIRONMENT=${ENVIRONMENT}"
          echo "  BUILD_SHA=${BUILD_SHA}"
          echo "  BUILD_RUN_ID=${BUILD_RUN_ID}"
          echo ""

      - name: Execute deployment (production)
        if: inputs.dry_run == false
        run: |
          set -euo pipefail
          
          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "🚀 PRODUCTION DEPLOYMENT MODE"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""
          echo "⚠️  WARNING: This is a production deployment!"
          echo ""
          echo "Current implementation is a stub."
          echo "Replace this step with actual deployment logic:"
          echo ""
          echo "Available environment variables:"
          echo "  FULL_IMAGE=${FULL_IMAGE}"
          echo "  IMAGE_TAG=${IMAGE_TAG}"
          echo "  RESOLVED_SHA=${RESOLVED_SHA}"
          echo "  RESOLVED_SHA_SHORT=${RESOLVED_SHA_SHORT}"
          echo "  ENVIRONMENT=${ENVIRONMENT}"
          echo "  BUILD_SHA=${BUILD_SHA}"
          echo "  BUILD_RUN_ID=${BUILD_RUN_ID}"
          echo ""
          echo "  # Example SSH + Docker:"
          echo "  ssh deploy@target 'docker pull ${FULL_IMAGE} && docker-compose up -d'"
          echo ""
          echo "  # Example Kubernetes:"
          echo "  kubectl set image deployment/app app=${FULL_IMAGE} -n ${ENVIRONMENT}"
          echo ""
          echo "  # Example Helm:"
          echo "  helm upgrade app ./chart --set image.tag=${IMAGE_TAG} -n ${ENVIRONMENT}"
          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "✅ Deployment stub completed"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

